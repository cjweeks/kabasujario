{"version":3,"sources":["game.js"],"names":[],"mappings":"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","file":"game-compiled.js","sourcesContent":["\r\n\r\n// The maximum number of players that may exist in one gameLogic gameLogic\r\nconst MAX_PLAYERS_PER_GAME = 7;\r\n\r\n// The refresh rate of the standard timers (in ms)\r\nconst TIMER_PERIOD = 4;\r\n\r\n// The refresh period of physics simulations (in ms)\r\nconst PHYSICS_UPDATE_PERIOD = 15;\r\n\r\n// The period at which to perform pings of the server (in ms)\r\nconst PING_PERIOD = 1000;\r\n\r\n// The expected frame rate of the simulation (in fps)\r\nconst FPS = 60;\r\n\r\n// the size of each player and block\r\nconst SQUARE_SIZE = 40;\r\n\r\n// the outline size of both players and blocks\r\nconst OUTLINE_SIZE = 4;\r\n\r\n// the distance between attached squares of a player\r\nconst SQUARE_SEPARATION = SQUARE_SIZE + OUTLINE_SIZE / 2;\r\n\r\n// the fill color of the player's square\r\nconst SQUARE_COLOR_PLAYER = 'rgba(45, 48, 146, 1)';\r\n\r\n// the fill color of blocks\r\nconst SQUARE_COLOR_BLOCK = 'rgba(0, 173, 238, 1)';\r\n\r\n// the fill color of solutions blocks\r\nconst SQUARE_COLOR_SOLUTION = 'rgba(120, 120, 120, 1)';\r\n\r\n// the default outline color of a player\r\nconst SQUARE_OUTLINE_COLOR_DEFAULT = 'rgba(255, 255, 255, 1)';\r\n\r\n// the color representing the active edge of a player (the edge that may attach to a block)\r\nconst SQUARE_OUTLINE_COLOR_ACTIVE = 'rgba(255, 40, 242, 1)';\r\n\r\n// the maximum number of blocks a player may attach to\r\nconst MAX_PLAYER_BLOCKS = 15;\r\n\r\n// the maximum distance a player can be from the solution to become valid\r\nconst MAX_SOLUTION_DISTANCE = SQUARE_SIZE / 2;\r\n\r\n// the maximum distance a player can be from a block to attach to it.\r\nconst MAX_PICKUP_DISTANCE = 2 * SQUARE_SIZE;\r\n\r\n// the amount of time (in ms) to hold the player in the solution\r\nconst SOLUTION_HOLD_TIME = 2000;\r\n\r\n// the number of rows for the puzzle grid\r\nconst NUM_ROWS = 16;\r\n\r\n// the number of columns for the puzzle grid\r\nconst NUM_COLS = 11;\r\n\r\n// the maximum health value of a block\r\nconst MAX_HEALTH = 100;\r\n\r\n// the width offset of the leaderboard from the right of the screen\r\nconst LEADERBOARD_WIDTH_OFFSET = 300;\r\n\r\n// the height offset of the leaderboard from the top of the screen\r\nconst LEADERRBOARD_HEIGHT_OFFSET = 50;\r\n\r\n// the height separation between elements in the leaderboard\r\nconst LEADERBOARD_HEIGHT_SEPARATION = 20;\r\n\r\n// the maximum number of players shown on the leaderboard\r\nconst LEADERBOARD_MAX_PLAYERS = MAX_PLAYERS_PER_GAME;\r\n\r\n// the amount to multiply the number of solution blocks by to obtain a score increment\r\nconst SCORE_SCALE_FACTOR = 10;\r\n\r\n// the period at which to generate new random blocks\r\nconst BLOCK_GENERATION_PERIOD = 30000;\r\n\r\nconst MAX_BLOCKS_GENERATED = 180;\r\n\r\n\r\n/**\r\n * Returns true if the code is being run on the server.\r\n * @returns {boolean}\r\n */\r\nfunction onServer() {\r\n    return typeof window == 'undefined' || !window.document;\r\n}\r\n\r\n/**\r\n * Sets the opacity of a color string in the form rgba(R, G, B, A)\r\n * @param color The color string to alter.\r\n * @param opacity The new opacity value.\r\n */\r\nfunction setOpacity(color, opacity) {\r\n    return color.replace(/[^,]+(?=\\))/, opacity.toString());\r\n}\r\n\r\n// load the uuid module is we are on the server for block generation\r\nlet uuid;\r\nif (onServer()) {\r\n    uuid = require('uuid/v1');\r\n}\r\n\r\n/*********************************** Edge ***********************************/\r\n\r\n/**\r\n * Specifies a set of directions corresponding to edges of squares / blocks. This is used for highlughting\r\n * certain edges as well as attaching blocks to players.\r\n */\r\nconst edge = {\r\n    TOP: 'top',\r\n    BOTTOM: 'bottom',\r\n    LEFT: 'left',\r\n    RIGHT: 'right',\r\n    NONE: 'none',\r\n    ALL: 'all',\r\n    /**\r\n     * Returns true if the given value is a valid edge.\r\n     * @param edge the value to check.\r\n     * @returns {boolean}\r\n     */\r\n    valid: function (edge) {\r\n        return edge == this.TOP || edge == this.BOTTOM || edge == this.LEFT || edge == this.RIGHT;\r\n    },\r\n\r\n    /**\r\n     * Returns the edge value opposite to the given edge.\r\n     * @param edge The edge to find the opposite of.\r\n     * @returns {*} The opposite edge value.\r\n     */\r\n    opposite: function (edge) {\r\n        let opposite = this.NONE;\r\n        if (edge == this.TOP) {\r\n            opposite = this.BOTTOM;\r\n        } else if (edge == this.BOTTOM) {\r\n            opposite = this.TOP;\r\n        } else if (edge == this.LEFT) {\r\n            opposite = this.RIGHT;\r\n        } else if (edge == this.RIGHT) {\r\n            opposite = this.LEFT;\r\n        }\r\n        return opposite;\r\n    },\r\n\r\n    /**\r\n     * Returns an edge given a direction vector between two objects.\r\n     * @param direction The vector pointing from the object of analysis\r\n     * (the object we wish to assign an edge to) and the secondary object.\r\n     * @returns {*} The edge passed through from traversing the vector.\r\n     */\r\n    getEdgeFromDirection: function (direction) {\r\n        let edge;\r\n        if (direction.x > 0) {\r\n            if (Math.abs(direction.y) < direction.x) {\r\n                edge = this.LEFT;\r\n            } else if (direction.y >= direction.x) {\r\n                edge = this.TOP;\r\n            } else {\r\n                edge = this.BOTTOM;\r\n            }\r\n        } else {\r\n            if (Math.abs(direction.y) < -direction.x) {\r\n                edge = this.RIGHT;\r\n            } else if (direction.y >= -direction.x) {\r\n                edge = this.TOP;\r\n            } else {\r\n                edge = this.BOTTOM;\r\n            }\r\n        }\r\n        return edge;\r\n    },\r\n\r\n    /**\r\n     * Creates an object of colors for outlining a rectangle.\r\n     * @param edge The edge that will be highlighted.\r\n     * @param edgeColor The highlighting color of the provided edge.\r\n     * @param defaultColor The color of the non-highlighted edges.\r\n     * @returns {*} An object consisting of each edge-color pair.\r\n     */\r\n    formatColors: function (edge, edgeColor, defaultColor) {\r\n        let colors;\r\n        if (edge == this.TOP) {\r\n            colors = {\r\n                top: edgeColor,\r\n                bottom: defaultColor,\r\n                left: defaultColor,\r\n                right: defaultColor\r\n            }\r\n        } else if (edge == this.BOTTOM) {\r\n            colors = {\r\n                top: defaultColor,\r\n                bottom: edgeColor,\r\n                left: defaultColor,\r\n                right: defaultColor\r\n            }\r\n        } else if (edge == this.LEFT) {\r\n            colors = {\r\n                top: defaultColor,\r\n                bottom: defaultColor,\r\n                left: edgeColor,\r\n                right: defaultColor\r\n            }\r\n        } else if (edge == this.RIGHT) {\r\n            colors = {\r\n                top: defaultColor,\r\n                bottom: defaultColor,\r\n                left: defaultColor,\r\n                right: edgeColor\r\n            }\r\n        } else {\r\n            colors = {\r\n                top: defaultColor,\r\n                bottom: defaultColor,\r\n                left: defaultColor,\r\n                right: defaultColor\r\n            }\r\n        }\r\n        return colors;\r\n    },\r\n\r\n    /**\r\n     * Returns a unit vector equal to the relative position of\r\n     * the given edge to (0, 0).\r\n     * @param edge The edge to find the relative position of.\r\n     * @returns {*|{x: (*|number), y: (*|number)}} The relative\r\n     * position unit vector.\r\n     */\r\n    getRelativePosition: function (edge) {\r\n        let relativePosition = vector.construct();\r\n        if (edge == this.TOP) {\r\n            relativePosition = vector.construct(0, -1);\r\n        } else if (edge == this.BOTTOM) {\r\n            relativePosition = vector.construct(0, 1);\r\n        } else if (edge == this.RIGHT) {\r\n            relativePosition = vector.construct(1, 0);\r\n        } else if (edge == this.LEFT) {\r\n            relativePosition = vector.construct(-1, 0);\r\n        }\r\n\r\n        return relativePosition;\r\n    }\r\n};\r\n\r\n/*********************************** Vector ***********************************/\r\n\r\n/**\r\n * Calculates the linear interpolation between the given valuesat the\r\n * specified interpolation point.\r\n * @param firstValue The first value.\r\n * @param secondValue The second value.\r\n * @param interpolationPoint A number between 0 and 1 that indicates\r\n * the point at which the interpolation is given. If this value is 0,\r\n * 'firstValue' is returned; if thi value is 1, 'secondValue' is returned.\r\n * @returns {string} The value o the linear interpolation at the given point.\r\n */\r\nfunction interpolate(firstValue, secondValue, interpolationPoint) {\r\n    interpolationPoint = (Math.max(0, Math.min(1, interpolationPoint)));\r\n    return (firstValue + interpolationPoint * (secondValue - firstValue));\r\n}\r\n\r\n/**\r\n * Returns a random integer in the given interval.\r\n * @param min The minimum possible value (inclusive)\r\n * @param max The maximum possible value (exclusive).\r\n * @returns {number}\r\n */\r\nfunction getRandomInt(min, max) {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n}\r\n\r\n/**\r\n * Simple functions acting on a two-dimensional Vector.\r\n * A vector in this case is any object with numerical\r\n * properties 'x' and 'y'.\r\n */\r\nconst vector = {\r\n\r\n    /**\r\n     * Adds the two given vectors.\r\n     * @param u the first vector.\r\n     * @param v The second vector to add.\r\n     * @returns {vector} A new vector, the result of u + v.\r\n     */\r\n    add: function (u, v) {\r\n        return {\r\n            x: u.x + v.x,\r\n            y: u.y + v.y\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Subtracts the two given vectors.\r\n     * @param u the first vector.\r\n     * @param v The second vector to subtract.\r\n     * @returns {vector} A new vector, the result of u - v.\r\n     */\r\n    subtract: function (u, v) {\r\n        return this.add(u, this.scalarMultiply(v, -1));\r\n    },\r\n\r\n    /**\r\n     * Returns the euclidean magnitude of the given vector.\r\n     * @param v the vector to measure.\r\n     * @returns {number}\r\n     */\r\n    magnitude: function (v) {\r\n        // console.log('mag: ' + Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2)));\r\n        return Math.sqrt(Math.pow(v.x, 2) + Math.pow(v.y, 2))\r\n    },\r\n\r\n    /**\r\n     * Returns the unit Vector with the sample direction\r\n     * as the given vector.\r\n     * @returns {vector}\r\n     */\r\n    unitVector: function (v) {\r\n        const magnitude = this.magnitude(v);\r\n        if (magnitude == 0) {\r\n            return {\r\n                x: 0,\r\n                y: 0\r\n            }\r\n        }\r\n        return {\r\n            x: v.x / magnitude,\r\n            y: v.y / magnitude\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Returns the result of multiplication of the given\r\n     * vector and the given scalar.\r\n     * @param v The vector to multiply.\r\n     * @param scalar The scalar to multiply this Vector by.\r\n     * @returns {vector} The new scaled vector after multiplication.\r\n     */\r\n    scalarMultiply: function (v, scalar) {\r\n        return {\r\n            x: v.x * scalar,\r\n            y: v.y * scalar\r\n        };\r\n    },\r\n\r\n\r\n    /**\r\n     * Returns true if the given vector is teh zero vector\r\n     * (both x and y components are zero).\r\n     * @returns {boolean}\r\n     */\r\n    isZero: function (v) {\r\n        return v.x == 0 && v.y == 0;\r\n    },\r\n\r\n    /**\r\n     * Returns the linear interpolation between this vector\r\n     * and the given vector.\r\n     * @param u The starting vector.\r\n     * @param v The ending vector.\r\n     * @param interpolationPoint The point at which to perform\r\n     * the interpolation (see interpolate() for more information)\r\n     * @returns {vector} A new vector; the result of the interpolation.\r\n     */\r\n    interpolate: function (u, v, interpolationPoint) {\r\n        return {\r\n            x: interpolate(u.x, v.x, interpolationPoint),\r\n            y: interpolate(u.y, v.y, interpolationPoint)\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Returns a new vector from an arbitrary object having\r\n     * both x and y properties.\r\n     * @param object the object to create the vector from.\r\n     * @returns {vector} A vector with the same components\r\n     * as the input object.\r\n     */\r\n    generate: function (object) {\r\n        return {\r\n            x: object.x,\r\n            y: object.y\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Returns a vector given the x and y components.\r\n     * @param x The x component (defaults to zero).\r\n     * @param y The y component (defaults to zero).\r\n     * @returns {{x: (*|number), y: (*|number)}} A vector\r\n     * with the given components.\r\n     */\r\n    construct: function (x, y) {\r\n        x = x || 0;\r\n        y = y || 0;\r\n        return {\r\n            x: x,\r\n            y: y\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Returns the given vector in string form\r\n     * @param v the vector to return a string version of.\r\n     * @returns {string} the components of v: '(v.x, v.y)'\r\n     */\r\n    print: function (v) {\r\n        return '(' + v.x + ', ' + v.y + ')';\r\n    },\r\n\r\n    /**\r\n     * Returns true if the components of the two vectors\r\n     * are equal.\r\n     * @param u The first vector to compare.\r\n     * @param v The second vector to compare.\r\n     * @returns {boolean}\r\n     */\r\n    isEqual: function (u, v) {\r\n        return u.x == v.x && u.y == v.y;\r\n    }\r\n};\r\n\r\n\r\n/*********************************** Game Logic ***********************************/\r\n\r\nconst world = {\r\n    width: 4000,\r\n    height: 4000\r\n};\r\n\r\n/**\r\n * This object controls the physics of the\r\n * upper-level gameLogic object and is used on\r\n * both the client and the server.\r\n * @param game The upper-level gameLogic object\r\n * this object corresponds to.\r\n */\r\nclass GameLogic {\r\n\r\n    constructor() {\r\n        // container holding players identified by their IDs\r\n        this.players = {};\r\n\r\n        // container holding blocks identified by their IDs\r\n        this.blocks = {};\r\n\r\n        // create a list of possible solutions from which to choose\r\n        this.possibleSolutions = [\r\n            {\r\n                blocks: [\r\n                    vector.construct(),\r\n                    vector.construct(0, 1),\r\n                    vector.construct(0, 2),\r\n                    vector.construct(0, 3),\r\n                    vector.construct(1, 0),\r\n                    vector.construct(2, 0),\r\n                    vector.construct(2, 1)\r\n                ],\r\n                width: 0,\r\n                height: 0\r\n            },\r\n            {\r\n                blocks: [\r\n                    vector.construct(),\r\n                    vector.construct(0, 1),\r\n                    vector.construct(1, 1),\r\n                    vector.construct(1, 0),\r\n                    vector.construct(1, 2),\r\n                    vector.construct(2, 1),\r\n                    vector.construct(2, 2)\r\n                ],\r\n                width: 0,\r\n                height: 0\r\n            },\r\n            {\r\n                blocks: [\r\n                    vector.construct(0, 1),\r\n                    vector.construct(0, 2),\r\n                    vector.construct(0, 3),\r\n                    vector.construct(0, 4),\r\n                    vector.construct(2, 0),\r\n                    vector.construct(3, 0),\r\n                    vector.construct(3, 1),\r\n                    vector.construct(3, 2),\r\n                    vector.construct(2, 2),\r\n                    vector.construct(1, 2)\r\n                ],\r\n                width: 0,\r\n                height: 0\r\n            },\r\n            {\r\n                blocks: [\r\n                    vector.construct(1, 0),\r\n                    vector.construct(1, 1),\r\n                    vector.construct(1, 2),\r\n                    vector.construct(1, 3),\r\n                    vector.construct(2, 1),\r\n                    vector.construct(2, 2),\r\n                    vector.construct(2, 3),\r\n                    vector.construct(3, 2),\r\n                    vector.construct(0, 3),\r\n                    vector.construct(0, 4),\r\n                    vector.construct(0, 5)\r\n                ],\r\n                width: 0,\r\n                height: 0\r\n            },\r\n            {\r\n                blocks: [\r\n                    vector.construct(0, 0),\r\n                    vector.construct(1, 0),\r\n                    vector.construct(2, 0),\r\n                    vector.construct(3, 0),\r\n                    vector.construct(4, 0),\r\n                    vector.construct(5, 0),\r\n                    vector.construct(1, 1),\r\n                    vector.construct(1, 2),\r\n                    vector.construct(2, 2),\r\n                    vector.construct(3, 2),\r\n                    vector.construct(3, 1)\r\n                ],\r\n                width: 0,\r\n                height: 0\r\n            },\r\n            {\r\n                blocks: [\r\n                    vector.construct(0, 0),\r\n                    vector.construct(0, 1),\r\n                    vector.construct(0, 2),\r\n                    vector.construct(0, 3),\r\n                    vector.construct(0, 4),\r\n                    vector.construct(1, 3),\r\n                    vector.construct(1, 4),\r\n                    vector.construct(1, 5),\r\n                    vector.construct(1, 6),\r\n                ],\r\n                width: 0,\r\n                height: 0\r\n            }\r\n        ];\r\n\r\n        // get a random solution from the above array (note this will change quickly on the client side when the\r\n        // server informs the client of the actual current solution).\r\n        this.solution = this.possibleSolutions[Math.floor(Math.random() * this.possibleSolutions.length)];\r\n\r\n        // determine the height and width of each solution\r\n        this.setSolutionDimensions();\r\n\r\n        // whether or not a player has locked to the solution\r\n        this.solutionOccupied = false;\r\n\r\n        this.solutionWidth = 3;\r\n        this.solutionHeight = 4;\r\n\r\n        // set up movement constants\r\n        this.MAX_DIRECTION_MAGNITUDE = 400.0;\r\n        this.MAX_PLAYER_SPEED = 300;\r\n\r\n\r\n        //Set up some physics integration values\r\n        this.physicsDeltaTime = 0.0001;\r\n        this.physicsPreviousTime = new Date().getTime();\r\n\r\n        // define the local timer\r\n        this.localTime = 0.016;\r\n\r\n        // the local delta time since the last timer tick\r\n        this.deltaTime = new Date().getTime();\r\n\r\n        // the local time of the previous timer tick\r\n        this.previousTime = new Date().getTime();\r\n\r\n        // begin processing the physics simulation\r\n        this.startPhysics();\r\n\r\n        // start the main timer\r\n        this.startTimer();\r\n    }\r\n\r\n    /**\r\n     * Sets the height and width attributes of each solution in possibleSolutions.\r\n     */\r\n    setSolutionDimensions() {\r\n        for (let i = 0; i < this.possibleSolutions.length; i++) {\r\n            let solution = this.possibleSolutions[i];\r\n            let xMax = 0;\r\n            let yMax = 0;\r\n            for (let j = 0; j < solution.blocks.length; j++) {\r\n                if (solution.blocks[j].x > xMax) {\r\n                    xMax = solution.blocks[j].x;\r\n                }\r\n                if (solution.blocks[j].y > yMax) {\r\n                    yMax = solution.blocks[j].y;\r\n                }\r\n            }\r\n            solution.width = xMax + 1;\r\n            solution.height = yMax + 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removed a player from the list of players.\r\n     * @param removePlayerId The id of the player to remove.\r\n     */\r\n    removePlayer(removePlayerId) {\r\n        if (this.players[removePlayerId]) {\r\n            delete this.players[removePlayerId];\r\n\r\n            // send a notification to each player\r\n            for (let playerId in this.players) {\r\n                if (playerId != removePlayerId && this.players.hasOwnProperty(playerId)) {\r\n                    this.players[playerId].playerSocket.emit('player-removed', {\r\n                        clientPlayerId: removePlayerId\r\n                    });\r\n                }\r\n            }\r\n        } else {\r\n            console.log('Could not remove player ' + removePlayerId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts a high speed timer which updates the\r\n     * delta time and local time values.\r\n     */\r\n    startTimer() {\r\n        setInterval(function () {\r\n            const currentTime = new Date().getTime();\r\n            this.deltaTime = currentTime - this.previousTime;\r\n            this.previousTime = currentTime;\r\n            this.localTime += this.deltaTime;\r\n        }.bind(this), TIMER_PERIOD);\r\n    }\r\n    /**\r\n     * Starts a physics timer which updates the\r\n     * physics delta time, previous time, and\r\n     * updates the physics with a call to updatePhysics().\r\n     */\r\n    startPhysics() {\r\n        setInterval(function(){\r\n            const currentTime = new Date().getTime();\r\n            this.physicsDeltaTime = currentTime - this.physicsPreviousTime;\r\n            this.physicsPreviousTime = currentTime;\r\n            this.updatePhysics();\r\n        }.bind(this), PHYSICS_UPDATE_PERIOD);\r\n    }\r\n\r\n    update(time) {\r\n        // determine the delta time values\r\n        if (this.previousFrameTime) {\r\n            this.deltaTime = (time - this.previousFrameTime);\r\n        }\r\n        else {\r\n            this.deltaTime = 0.015; // TODO abstract this value (this is just an initial value)\r\n        }\r\n\r\n        //Store the last frame time\r\n        this.previousFrameTime = time;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Checks for collisions between the given player and\r\n     * the free floating blocks.\r\n     * @param player\r\n     */\r\n    checkCollisions(player) {\r\n\r\n        // iterate through each block in the player\r\n        for (let i = 0; i < player.blocks.length; i++) {\r\n\r\n            // get the absolute position of the current block\r\n            let blockPosition = vector.add(\r\n                player.position,\r\n                vector.scalarMultiply(player.blocks[i].position, SQUARE_SEPARATION)\r\n            );\r\n\r\n            // check collisions for each free floating block\r\n            for (let blockId in this.blocks) {\r\n                if (this.blocks.hasOwnProperty(blockId)) {\r\n                    // get a vector pointing from the object to the block\r\n                    let direction = vector.subtract(this.blocks[blockId].position, blockPosition);\r\n                    let closestEdge = edge.getEdgeFromDirection(direction);\r\n\r\n                    // reset the position if a block is overlapping\r\n                    if (closestEdge == edge.TOP && direction.y < SQUARE_SEPARATION) {\r\n                        player.position.y -= SQUARE_SEPARATION - direction.y;\r\n                    } else if (closestEdge == edge.BOTTOM && direction.y > -SQUARE_SEPARATION) {\r\n                        player.position.y += SQUARE_SEPARATION + direction.y\r\n                    } else if (closestEdge == edge.RIGHT && direction.x > -SQUARE_SEPARATION) {\r\n                        player.position.x += SQUARE_SEPARATION + direction.x;\r\n                    } else if (closestEdge == edge.LEFT && direction.x < SQUARE_SEPARATION) {\r\n                        player.position.x -= SQUARE_SEPARATION - direction.x;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // check collisions with the world borders\r\n\r\n            // left wall collision\r\n            if (blockPosition.x <= SQUARE_SIZE) {\r\n                player.position.x = SQUARE_SIZE + player.position.x - blockPosition.x;\r\n            }\r\n\r\n            // right wall collision\r\n            if (blockPosition.x >= world.width - SQUARE_SIZE) {\r\n                player.position.x = world.width - SQUARE_SIZE - (blockPosition.x - player.position.x);\r\n            }\r\n\r\n            // top wall collision\r\n            if (blockPosition.y <= SQUARE_SIZE) {\r\n                player.position.y = SQUARE_SIZE + player.position.y - blockPosition.y;\r\n            }\r\n\r\n            // bottom wall collision\r\n            if (blockPosition.y >= world.height - SQUARE_SIZE) {\r\n                player.position.y = world.height - SQUARE_SIZE - (blockPosition.y - player.position.y);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Processes a string of the given player's inputs.\r\n     * @param player The player to process.\r\n     * @returns {vector} The displacement vector calculated\r\n     * by summing each input direction.\r\n     */\r\n    processDirectionInputs(player) {\r\n        if (!player) {\r\n            console.log('NO PLAYER for id ' + this.clientPlayerId);\r\n            return vector.construct();\r\n        }\r\n        let scaledDirection = vector.construct();\r\n        if (player.inputs.length) {\r\n            scaledDirection = vector.construct();\r\n            for (let i = 0; i < player.inputs.length; i++) {\r\n                let input = player.inputs[i];\r\n                // only render inputs that have not yet been rendered\r\n                if (input.number > player.lastRenderedInputNumber) {\r\n                    // recall that the direction in an 'input' has already been normalized (see recordInput),\r\n                    // so no operations must be performed on it here\r\n                    scaledDirection = vector.add(scaledDirection, input.direction);\r\n                }\r\n            }\r\n\r\n            // set the values in the player to reflect the new rendering\r\n            let lastInput = player.inputs[player.inputs.length - 1];\r\n            player.lastInputTime = lastInput.time;\r\n            player.lastRenderedInputNumber = lastInput.number;\r\n        }\r\n        // return the displacement vector of the player\r\n        return vector.scalarMultiply(scaledDirection, (this.MAX_PLAYER_SPEED * PHYSICS_UPDATE_PERIOD / 1000.0));\r\n    }\r\n}\r\n\r\n\r\n/*********************************** Server Game Logic ***********************************/\r\n\r\nclass ServerGameLogic extends GameLogic {\r\n    constructor(game) {\r\n        super();\r\n        this.game = game;\r\n        if (this.game) {\r\n            // add the current players from the game object\r\n            for (let playerId in this.game.playerSockets) {\r\n                if (this.game.playerSockets.hasOwnProperty(playerId)) {\r\n                    this.players[playerId] = new ServerPlayer(this, this.game.playerSockets[playerId]);\r\n                }\r\n            }\r\n        }\r\n        this.inputs = [];\r\n        this.serverTime = 0;\r\n        this.previousState = {};\r\n        this.startBlockGeneration();\r\n    }\r\n\r\n    /**\r\n     * Generates a bounded random number of blocks on a timer\r\n     */\r\n    startBlockGeneration() {\r\n        setInterval(function () {\r\n            let numCurrentBlocks = 0;\r\n            for (let blockId in this.blocks) {\r\n                if (this.blocks.hasOwnProperty(blockId)) {\r\n                    numCurrentBlocks++;\r\n                }\r\n            }\r\n\r\n            let numNewBlocks = Math.floor(Math.random() * (MAX_BLOCKS_GENERATED - numCurrentBlocks));\r\n            console.log('generating ' + numNewBlocks + ' blocks');\r\n            this.generateBlocks(numNewBlocks);\r\n        }.bind(this), BLOCK_GENERATION_PERIOD)\r\n    }\r\n\r\n    /**\r\n     * Updates the game.\r\n     * @param time The current time.\r\n     */\r\n    update(time) {\r\n\r\n        // call the client / server common updates\r\n        super.update(time);\r\n\r\n        // update the server time using the time from the main timer\r\n        this.serverTime = this.localTime;\r\n        // create a light copy of each player\r\n        let playersLightCopy = {};\r\n        for (let playerId in this.players) {\r\n            if (this.players.hasOwnProperty(playerId)) {\r\n                playersLightCopy[playerId] = Player.lightCopy(this.players[playerId]);\r\n            }\r\n        }\r\n\r\n        // record the state of the game at the current time\r\n        let state = {\r\n            players: playersLightCopy,\r\n            blocks: this.blocks,\r\n            time: this.serverTime\r\n        };\r\n        // send the recorded state to each player\r\n        for (let playerId in this.players) {\r\n            if (this.players.hasOwnProperty(playerId)) {\r\n                let player = this.players[playerId];\r\n                if (player.playerSocket) {\r\n                    player.playerSocket.emit('server-update', state);\r\n                } else {\r\n                    console.log('Error: could not find player playerSocket when updating');\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    updatePhysics() {\r\n        // update player positions\r\n        for (let playerId in this.players) {\r\n            if (this.players.hasOwnProperty(playerId)) {\r\n                let player = this.players[playerId];\r\n                // obtain a displacement from the set of inputs provided by the player\r\n                let displacement = this.processDirectionInputs(player);\r\n\r\n                player.position = vector.add(\r\n                    player.position,\r\n                    displacement\r\n                );\r\n\r\n                this.checkCollisions(player);\r\n\r\n                // check the solutions\r\n                this.processSolutionLogic();\r\n                // clear all inputs that we have processed\r\n                player.inputs = [];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determines whether or not a player may solve the puzzle\r\n     * and begins the solution process if so.\r\n     */\r\n    processSolutionLogic() {\r\n        // check if the solution is occupied by another player\r\n        if (this.solutionOccupied) {\r\n            return;\r\n        }\r\n        // check if a player is in close proximity with a valid solution\r\n        let result = this.checkSolution();\r\n        if (!this.players[result.playerId]) {\r\n            return;\r\n        }\r\n\r\n        // occupy the solution, and lock the player's position for a given amount of time\r\n        this.solutionOccupied = true;\r\n        let player = this.players[result.playerId];\r\n\r\n        player.playerSocket.emit('set-position', {locked: true}, function () {\r\n            player.position = result.position;\r\n            let startTime = new Date().getTime();\r\n            // decrement the opacity of each block\r\n            let transparencyIntervalId = setInterval(function() {\r\n                let currentTime = new Date().getTime();\r\n                for (let i = 1; i < player.blocks.length; i++) {\r\n                    player.blocks[i].opacity = Math.max(0, 1 - (1 / SOLUTION_HOLD_TIME) * (currentTime - startTime));\r\n                }\r\n            }, PHYSICS_UPDATE_PERIOD);\r\n            setTimeout(function () {\r\n                // unlock the player's position, remove their blocks, and update their score\r\n                player.playerSocket.emit('set-position', {locked: false}, function () {});\r\n                player.blocks = player.blocks.slice(0, 1);\r\n                player.score += this.solution.blocks.length * SCORE_SCALE_FACTOR;\r\n\r\n                // select a new solution and emit a solution changed event\r\n                let newSolutionIndex = Math.floor(Math.random() * this.possibleSolutions.length);\r\n                for (let playerId in this.players) {\r\n                    if (this.players.hasOwnProperty(playerId)) {\r\n                        let player = this.players[playerId];\r\n                        if (player.playerSocket) {\r\n                            player.playerSocket.emit('solution-changed', {solutionIndex: newSolutionIndex});\r\n                        } else {\r\n                            console.log('Error: could not find player playerSocket when updating solution');\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.solution = this.possibleSolutions[newSolutionIndex];\r\n                this.solutionOccupied = false;\r\n                // stop decrementing the transparency of the player's blocks\r\n                clearInterval(transparencyIntervalId);\r\n            }.bind(this), SOLUTION_HOLD_TIME)\r\n        }.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Checks if any player is currently in close enough proximity\r\n     * to a solution and has the correct block orientations to\r\n     * complete the solution..\r\n     * @returns {{playerId: string, position: (*|{x: (*|number), y: (*|number)})}} An object\r\n     * containing the player id of the player and position of the block for which the\r\n     * player must bind to, if such a player exists.\r\n     */\r\n    checkSolution() {\r\n\r\n        // define the result to be returned\r\n        let result = {\r\n            playerId: '',\r\n            position: vector.construct()\r\n        };\r\n\r\n        // return if a player is already in the solution\r\n        if (this.solutionOccupied) {\r\n            return result;\r\n        }\r\n\r\n        for (let playerId in this.players) {\r\n            if (this.players.hasOwnProperty(playerId)) {\r\n                // check the position of the player's primary block\r\n                let playerPosition = this.players[playerId].position;\r\n                for (let i = 0; i < this.solution.blocks.length; i++) {\r\n\r\n                    // determine where the solution block is\r\n                    let x = world.width / 2 - NUM_COLS * SQUARE_SEPARATION + SQUARE_SEPARATION / 2;\r\n                    let y = world.height / 2 - NUM_ROWS * SQUARE_SEPARATION + SQUARE_SEPARATION / 2;\r\n\r\n                    let xOffset = Math.floor((NUM_COLS - this.solution.width) / 2) * SQUARE_SEPARATION;\r\n                    let yOffset = Math.ceil((NUM_ROWS - this.solution.height) / 2) * SQUARE_SEPARATION;\r\n\r\n                    let blockPosition = vector.construct(\r\n                        x + xOffset + this.solution.blocks[i].x * SQUARE_SEPARATION,\r\n                        y + yOffset + this.solution.blocks[i].y * SQUARE_SEPARATION\r\n                    );\r\n\r\n                    // find the distance between the solution block and the player's primary block\r\n                    let distance = vector.magnitude(vector.subtract(playerPosition, blockPosition));\r\n\r\n                    // if the distance is small enough, set the required values and exit the inner loop\r\n                    if (distance < MAX_SOLUTION_DISTANCE && this.checkSolutionValidity(playerId, this.solution.blocks[i])) {\r\n                        result.playerId = playerId;\r\n                        result.position = blockPosition;\r\n                        break;\r\n                    }\r\n                }\r\n                // exit the outer loop if a match has been foujd\r\n                if (result.playerId) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Determines whether or not a player meets the current solution.\r\n     * @param playerId\r\n     * @param relativePosition The relative position of the solution\r\n     * block that the player's primary block is intended to bind to.\r\n     * @returns {boolean}\r\n     */\r\n    checkSolutionValidity(playerId, relativePosition) {\r\n        if (!this.players[playerId]) {\r\n            return false;\r\n        }\r\n\r\n        let playerBlocks = this.players[playerId].blocks;\r\n\r\n        // checks the lengths of the solution and the player's blocks\r\n        if (playerBlocks.length != this.solution.blocks.length) {\r\n            return false;\r\n        }\r\n\r\n        // find the minimum x and y offset for the player's blocks\r\n        let xMin = 0;\r\n        let yMin = 0;\r\n        for (let i = 0; i < playerBlocks.length; i++) {\r\n            if (playerBlocks[i].position.x < xMin) {\r\n                xMin = playerBlocks[i].position.x;\r\n            }\r\n            if (playerBlocks[i].position.y < yMin) {\r\n                yMin = playerBlocks[i].position.y;\r\n            }\r\n        }\r\n\r\n        let offset = vector.construct(-xMin, -yMin);\r\n\r\n        // check that the relative position of the chosen solution block matches\r\n        // that of the player's primary block plus the offset above\r\n        let primaryBlockOffsetPosition = vector.add(playerBlocks[0].position, offset);\r\n        if (!vector.isEqual(primaryBlockOffsetPosition, relativePosition)) {\r\n            return false;\r\n        }\r\n\r\n        // check each block in the player against each block in the solution\r\n        let valid = true;\r\n        for (let i = 0; i < playerBlocks.length; i++) {\r\n            // get the current player block's position relative to 0, 0\r\n            let playerBlockPosition = vector.add(playerBlocks[i].position, offset);\r\n            let found = false;\r\n            for (let j = 0; j < this.solution.blocks.length; j++) {\r\n                if (vector.isEqual(playerBlockPosition, this.solution.blocks[j])) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                valid = false;\r\n                break;\r\n            }\r\n        }\r\n        return valid;\r\n    }\r\n\r\n    detach(playerId) {\r\n        if (!this.players[playerId] || this.players[playerId].blocks.length < 2) {\r\n            return;\r\n        }\r\n        // remove the most recently added block\r\n        let block = this.players[playerId].blocks.pop();\r\n\r\n        // set the position back to absolute and restore the health\r\n        block.position = vector.add(\r\n            vector.scalarMultiply(block.position, SQUARE_SEPARATION),\r\n            this.players[playerId].position\r\n        );\r\n        block.health = MAX_HEALTH;\r\n\r\n        // add the block to the list of blocks\r\n        let blockId = uuid();\r\n        this.blocks[blockId] = block;\r\n    }\r\n\r\n    /**\r\n     * Generates a set of randomly places blocks, as long as the blocks will not appear within the puzzle grid.\r\n     * @param numBlocks The number of blocks to generate.\r\n     */\r\n\r\n    generateBlocks(numBlocks) {\r\n        for (let i = 0; i < numBlocks; i++) {\r\n            // generate random x and y coordinates for the new block\r\n            let x = getRandomInt(SQUARE_SIZE / 2, world.width - SQUARE_SIZE / 2);\r\n            let y =  getRandomInt(SQUARE_SIZE / 2, world.height - SQUARE_SIZE / 2);\r\n\r\n            // if the position falls inside the solution grid, discard the created point and try again\r\n            if(x >= world.width / 2 - NUM_COLS * SQUARE_SEPARATION &&\r\n                x < world.width / 2 - NUM_COLS * SQUARE_SEPARATION  + NUM_COLS * SQUARE_SIZE &&\r\n                world.height / 2 - NUM_ROWS * SQUARE_SEPARATION &&\r\n                world.height / 2 - NUM_ROWS * SQUARE_SEPARATION + NUM_ROWS * SQUARE_SIZE){\r\n\r\n                i--;\r\n            } else {\r\n                // generate a block at the created position\r\n                let blockId = uuid();\r\n                this.blocks[blockId] = new Block(x, y);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the server-side players from information\r\n     * received from the client.\r\n     * @param playerId The player id of the client update.\r\n     * @param input The input object sent to the server.\r\n     */\r\n    processClientUpdate(playerId, input) {\r\n        let player = this.players[playerId];\r\n        if (!player) {\r\n            return;\r\n        }\r\n        player.inputs.push(input);\r\n    }\r\n}\r\n\r\n/*********************************** Client Game Logic ***********************************/\r\n\r\nclass ClientGameLogic extends GameLogic {\r\n    /**\r\n     * Creates a new client game logic object.\r\n     * @param camera the camera object used for tracking.\r\n     */\r\n    constructor(camera) {\r\n        super();\r\n\r\n        // the id of the player associated with this client instance\r\n        this.clientPlayerId = '';\r\n\r\n        // the player object identified by clientPlayerId\r\n        this.clientPlayer = undefined;\r\n\r\n        // TODO remove\r\n        this.predictMovement = true;\r\n\r\n        // the camera object that will allow us to draw the player at the center of the screen\r\n        this.camera = camera;\r\n        console.log(this.camera);\r\n\r\n        // a reference to the two-dimensional context of the canvas to render on\r\n        this.context = {};\r\n\r\n        // whether or not the position is locked by the server\r\n        this.lockPosition = false;\r\n\r\n        // collection of the various client inputs based on the keyboard and mouse\r\n        this.clientState = {\r\n            // a vector containing the mouse direction relative to to the client player's position\r\n            mousePosition: vector.construct(),\r\n\r\n            // whether or not the player's movement is enabled\r\n            movementEnabled: true\r\n        };\r\n\r\n        // the current input number; used to identify inputs recorded and sent to the server\r\n        this.inputNumber = 0;\r\n\r\n        // the amount to smooth client movement if it lags behind the server\r\n        this.clientSmoothing = 0.1;\r\n\r\n        // the net latency and ping between the client and server (initial values are placeholders)\r\n        this.netLatency = 0.001;\r\n        this.netPing = 0.001;\r\n        this.previousPingTime = 0.001;\r\n\r\n        // the amount of time (in ms) the other players lag behind the real server time in the client's rendering\r\n        // this is done to allow for smooth interpolation of other players' movements\r\n        this.clientServerOffset = 100;\r\n\r\n        // the length (in seconds) of the server history buffer that the client keeps in 'serverUpdates'\r\n        // the actual buffer size is the frame rate multiplied by this value\r\n        this.bufferLength = 2;\r\n        this.targetTime = 0.01;            //the time where we want to be in the server timeline\r\n\r\n        // the oldest server update time in the server updates buffer\r\n        this.oldestUpdateTime = 0.01;\r\n\r\n        // the current server time minus the client server offset; this is the time at which other players are drawn\r\n        this.clientTime = 0.01;\r\n\r\n        // the server time, as retrieved from the last server update\r\n        this.serverTime = 0.01;\r\n\r\n        // recent server updates that allow for interpolation of player positions\r\n        this.serverUpdates = [];\r\n\r\n        // connect to the server using socket.io\r\n        this.connect();\r\n\r\n        // start the ping timer to record latency\r\n        this.startPingTimer();\r\n    }\r\n\r\n\r\n    /**\r\n     * This is the main update loop for the client.\r\n     * It clears the canvas, records the client player's input,\r\n     * processes the server's updates, updates the client's local\r\n     * position, and finally re-draws everything.\r\n     */\r\n    update(time) {\r\n\r\n        // perform server / client common updates\r\n        super.update(time);\r\n\r\n        // clear the entire context\r\n        this.context.clearRect(0, 0, world.width, world.height);\r\n\r\n        // get the client player's inputs\r\n        this.recordInput();\r\n\r\n        // update the remote players (and the client player if prediction is disabled)\r\n        this.processServerUpdates();\r\n\r\n        // update the camera object to reflect new positions\r\n        this.camera.update();\r\n\r\n        // determine if a block is close enough to the client player to attach\r\n        this.determineCandidateBlock();\r\n\r\n        let leaderBoard = this.constructLeaderBoard();\r\n        this.drawLeaderBoard(leaderBoard);\r\n        // draw the puzzle grid and solutions\r\n        this.drawPuzzle();\r\n\r\n        // draw every player\r\n        this.drawPlayers();\r\n\r\n        // draw every block\r\n        this.drawBlocks();\r\n\r\n        // schedule the next update\r\n        this.scheduleUpdate();\r\n    }\r\n\r\n\r\n    /**\r\n     * Starts a sequence of pings to determine connection quality\r\n     * and adapt the local time.\r\n     */\r\n    startPingTimer() {\r\n        setInterval(function(){\r\n            this.previousPingTime = new Date().getTime();\r\n            this.playerSocket.emit('manual-ping', {\r\n                time: this.previousPingTime\r\n            });\r\n        }.bind(this), PING_PERIOD);\r\n    };\r\n\r\n    /**\r\n     * Requests a new animation from with update() as the callback.\r\n     */\r\n    scheduleUpdate() {\r\n        this.updateId = window.requestAnimationFrame(this.update.bind(this));\r\n    }\r\n\r\n\r\n    /**\r\n     * Normalizes the given direction vector.  This first checks if the\r\n     * vector is lower than size of the player and returns the zero vector\r\n     * if true. If this is false, the direction vector is scaled to reflect\r\n     * a linear relationship between the magnitude and the maximum speed; the\r\n     * resulting vector is has a magnitude between 0 and 1; vectors larger\r\n     * than 1 are automatically resized to a unit vectors.\r\n     * @param directionVector The direction vector to normalize.\r\n     * @returns {*} The normalized direction vector.\r\n     */\r\n    normalizeDirection(directionVector) {\r\n\r\n        // if the player's block is close enough to the mouse or if the player's movement is not enabled,\r\n        // interpret that as a direction of (0, 0)\r\n        if (vector.magnitude(directionVector) < SQUARE_SIZE / 2 || !this.clientState.movementEnabled || this.lockPosition) {\r\n            return vector.construct();\r\n        }\r\n\r\n        // scale down the direction vector by the maximum possible magnitude\r\n        let normalized = vector.scalarMultiply(directionVector, 1.0 / this.MAX_DIRECTION_MAGNITUDE);\r\n\r\n        // if the resulting vector is too large, convert it into a unit vector\r\n        if (vector.magnitude(normalized) > 1) {\r\n            normalized = vector.unitVector(normalized);\r\n        }\r\n\r\n        return normalized;\r\n    }\r\n\r\n    /**\r\n     * Draws the puzzle grid and the current solutions.\r\n     */\r\n    drawPuzzle() {\r\n        // draw a grid in the center of the world\r\n        // define the x and y coordinates of the top left of the grid\r\n        let x = world.width / 2 - NUM_COLS * SQUARE_SEPARATION - this.camera.xView;\r\n        let y = world.height / 2 - NUM_ROWS * SQUARE_SEPARATION - this.camera.yView;\r\n\r\n        let xOffset = Math.floor((NUM_COLS - this.solution.width) / 2) * SQUARE_SEPARATION;\r\n        let yOffset = Math.ceil((NUM_ROWS - this.solution.height) / 2) * SQUARE_SEPARATION;\r\n\r\n        // draw the solution\r\n        this.context.fillStyle = SQUARE_COLOR_SOLUTION;\r\n        for (let i = 0; i < this.solution.blocks.length; i++) {\r\n            this.context.fillRect(\r\n                x + xOffset + this.solution.blocks[i].x * SQUARE_SEPARATION,\r\n                y + yOffset + this.solution.blocks[i].y * SQUARE_SEPARATION,\r\n                SQUARE_SEPARATION,\r\n                SQUARE_SEPARATION\r\n            );\r\n        }\r\n\r\n        // draw vertical lines\r\n        for (let columnNumber = 0; columnNumber < NUM_COLS; columnNumber++) {\r\n            let yStart = y;\r\n            let yEnd = y + (NUM_ROWS  - 1) * SQUARE_SEPARATION;\r\n\r\n            // draw the first and last column lines longer to correct corners\r\n            if (columnNumber == 0 || columnNumber == NUM_COLS - 1) {\r\n                yStart -= OUTLINE_SIZE / 4;\r\n                yEnd += OUTLINE_SIZE / 4 ;\r\n            }\r\n            this.context.moveTo(x + columnNumber * SQUARE_SEPARATION, yStart);\r\n            this.context.lineTo(x + columnNumber * SQUARE_SEPARATION, yEnd);\r\n        }\r\n\r\n        // draw horizontal lines\r\n        for (let rowNumber = 0; rowNumber < NUM_ROWS; rowNumber++) {\r\n            this.context.moveTo(x, y + rowNumber * SQUARE_SEPARATION);\r\n            this.context.lineTo(x + (NUM_COLS -1 ) * SQUARE_SEPARATION, y + rowNumber * SQUARE_SEPARATION);\r\n        }\r\n\r\n        this.context.strokeStyle = 'rgb(255, 255, 255)';\r\n        this.context.lineWidth = OUTLINE_SIZE / 2;\r\n        this.context.stroke();\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * Draws each player.\r\n     */\r\n    drawPlayers() {\r\n        for (let playerId in this.players) {\r\n            if (this.players.hasOwnProperty(playerId)) {\r\n                Player.draw(this.players[playerId], this.context, this.camera);\r\n                //console.log(\"PLAYER NAME   \" + this.players[playerId].name);\r\n            }\r\n        }\r\n    }\r\n\r\n    constructLeaderBoard() {\r\n        let board = [];\r\n\r\n        for (let playerId in this.players) {\r\n            if (this.players.hasOwnProperty(playerId)) {\r\n                board.push({\r\n                    playerId: playerId,\r\n                    name: this.players[playerId].name,\r\n                    score: this.players[playerId].score\r\n                });\r\n            }\r\n        }\r\n\r\n        board.sort(function (firstEntry, secondEntry) {\r\n            if (firstEntry.score > secondEntry.score) {\r\n                return -1;\r\n            }\r\n            if (firstEntry.score < secondEntry.score) {\r\n                return 1;\r\n            }\r\n            // first must be equal to second\r\n            return 0;\r\n        });\r\n\r\n        return board;\r\n    }\r\n\r\n    drawLeaderBoard(leaderBoard){\r\n        let wView = this.camera.wView;\r\n        let hView = this.camera.hView;\r\n\r\n        wView = this.camera.wView;\r\n        hView = this.camera.hView;\r\n\r\n\r\n        for(let i = 0; i < leaderBoard.length && i < LEADERBOARD_MAX_PLAYERS; i++){\r\n            this.context.fillStyle = 'rgba(255, 255, 255, 1)';\r\n            if (leaderBoard[i].playerId == this.clientPlayerId) {\r\n                this.context.fillStyle = SQUARE_COLOR_BLOCK;\r\n            }\r\n            this.context.fillText(\r\n                i+1 + \". \" + leaderBoard[i].name + ':' + leaderBoard[i].score,\r\n                wView - LEADERBOARD_WIDTH_OFFSET,\r\n                LEADERRBOARD_HEIGHT_OFFSET + LEADERBOARD_HEIGHT_SEPARATION * i,\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws every block.\r\n     */\r\n    drawBlocks() {\r\n        for (let blockId in this.blocks) {\r\n            if (this.blocks.hasOwnProperty(blockId)) {\r\n                let outlineColor = SQUARE_OUTLINE_COLOR_DEFAULT;\r\n                if (blockId == this.clientPlayer.candidateBlockId) {\r\n                    outlineColor = SQUARE_OUTLINE_COLOR_ACTIVE;\r\n                }\r\n                Block.draw(\r\n                    this.blocks[blockId],\r\n                    this.context,\r\n                    this.camera,\r\n                    outlineColor,\r\n                    edge.opposite(this.clientPlayer.activeEdge)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determines the closest block to the client player and\r\n     * assigns this block as the player's candidate block if\r\n     * it is within a limit distance.\r\n     */\r\n    determineCandidateBlock() {\r\n        if (!this.clientPlayer || !this.clientPlayer.blocks.length) {\r\n            return;\r\n        }\r\n\r\n        let closestBlockId;\r\n        let clientBlockIndex;\r\n        let closestDistance = 0;\r\n        let start = true;\r\n        for (let blockId in this.blocks) {\r\n            if (this.blocks.hasOwnProperty(blockId)) {\r\n                for (let i = 0; i < this.clientPlayer.blocks.length; i++) {\r\n                    if (start) {\r\n                        // automatically set the minimum block to the first block\r\n                        start = false;\r\n                        closestBlockId = blockId;\r\n                        clientBlockIndex = i;\r\n                        closestDistance = vector.magnitude(\r\n                            vector.subtract(\r\n                                vector.add(\r\n                                    this.clientPlayer.position,\r\n                                    vector.scalarMultiply(\r\n                                        this.clientPlayer.blocks[i].position,\r\n                                        SQUARE_SEPARATION\r\n                                    )\r\n                                ),\r\n                                this.blocks[blockId].position\r\n                            )\r\n                        );\r\n                    } else {\r\n                        // set distance if it is less than the current minimum\r\n                        let distance = vector.magnitude(\r\n                            vector.subtract(\r\n                                vector.add(\r\n                                    this.clientPlayer.position,\r\n                                    vector.scalarMultiply(\r\n                                        this.clientPlayer.blocks[i].position,\r\n                                        SQUARE_SEPARATION\r\n                                    )\r\n                                ),\r\n                                this.blocks[blockId].position\r\n                            )\r\n                        );\r\n                        if (distance < closestDistance) {\r\n                            closestBlockId = blockId;\r\n                            clientBlockIndex = i;\r\n                            closestDistance = distance;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // if the closest block is close enough, mark it\r\n        if (closestDistance < MAX_PICKUP_DISTANCE) {\r\n            // assign the block id to the client player\r\n            this.clientPlayer.candidateBlockId = closestBlockId;\r\n            this.clientPlayer.activeBlockIndex = clientBlockIndex;\r\n\r\n            // recalculate the vector between the two points\r\n            let direction = vector.subtract(\r\n                vector.add(\r\n                    this.clientPlayer.position,\r\n                    vector.scalarMultiply(\r\n                        this.clientPlayer.blocks[clientBlockIndex].position,\r\n                        SQUARE_SEPARATION\r\n                    )\r\n                ),\r\n                this.blocks[closestBlockId].position\r\n            );\r\n\r\n            // assign the client player's active edge based on the direction\r\n            this.clientPlayer.activeEdge = edge.getEdgeFromDirection(direction);\r\n        } else {\r\n            this.clientPlayer.candidateBlockId = '';\r\n            this.clientPlayer.activeBlockIndex = 0;\r\n            this.clientPlayer.activeEdge = edge.NONE;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Attempts to attach the candidate block to the the player.\r\n     */\r\n    attach() {\r\n        if (!this.clientPlayer ||\r\n            !this.clientPlayer.candidateBlockId ||\r\n            !this.clientPlayer.activeEdge ||\r\n            !(this.clientPlayer.activeBlockIndex >= 0) ||\r\n            !this.blocks[this.clientPlayer.candidateBlockId] ||\r\n            this.clientPlayer.blocks.length > MAX_PLAYER_BLOCKS) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            // determine the relative position of the new block\r\n            let relativePosition = edge.getRelativePosition(this.clientPlayer.activeEdge);\r\n            relativePosition = vector.add(\r\n                relativePosition,\r\n                this.clientPlayer.blocks[this.clientPlayer.activeBlockIndex].position\r\n            );\r\n            // check if the client player already has a block at the relative position\r\n            for (let i = 0; i < this.clientPlayer.blocks.length; i++) {\r\n                if (vector.isEqual(this.clientPlayer.blocks[i].position, relativePosition)) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // add an offset for the active block the new block is attaching to\r\n            console.log('attaching to block ' + this.clientPlayer.activeBlockIndex);\r\n            // relativePosition = vector.add(\r\n            //     relativePosition,\r\n            //     this.clientPlayer.blocks[this.clientPlayer.activeBlockIndex].position\r\n            // );\r\n\r\n            // TODO determine whether or not this should happen on the client before the server\r\n            // add a new block to the client player's list\r\n            //this.clientPlayer.blocks.push(new Block(relativePosition.x, relativePosition.y));\r\n\r\n            // delete the block from the list of blocks\r\n            //delete this.blocks[this.clientPlayer.candidateBlockId];\r\n\r\n            // emit an attach event, signaling the server of the changes\r\n            this.playerSocket.emit('attach', {\r\n                playerId: this.clientPlayerId,\r\n                blockId: this.clientPlayer.candidateBlockId,\r\n                relativePosition: relativePosition\r\n            })\r\n\r\n        } catch (error) {\r\n            // this happens when someone spams the attach key for an unknown reason\r\n            console.log('Caught attach error -' + error);\r\n        }\r\n    }\r\n\r\n    detach() {\r\n        if (!this.clientPlayer || this.clientPlayer.blocks.length < 2) {\r\n            return;\r\n        }\r\n\r\n        // remove and retrieve the most recently added block\r\n        // let block = this.clientPlayer.blocks.pop();\r\n        //\r\n        // // set the position back to absolute and restore the health\r\n        // block.position = vector.add(\r\n        //     vector.scalarMultiply(block.position, SQUARE_SEPARATION),\r\n        //     this.clientPlayer.position\r\n        // );\r\n        // block.health = MAX_HEALTH;\r\n\r\n        // send a detach event to the server for processing\r\n        this.playerSocket.emit('detach', {\r\n            playerId: this.clientPlayerId\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * Updates the physics of the client player.\r\n     */\r\n    updatePhysics() {\r\n        if (!this.clientPlayer) {\r\n            return;\r\n        }\r\n\r\n        // save the current state of the client player, and handle new inputs to determine a new position\r\n        this.clientPlayer.previousState.position = vector.generate(this.clientPlayer.position);\r\n        let displacement = this.processDirectionInputs(this.clientPlayer);\r\n        this.clientPlayer.position = vector.add(this.clientPlayer.position, displacement);\r\n        this.checkCollisions(this.clientPlayer);\r\n    }\r\n\r\n    /**\r\n     * Records mouse input and appends it to the list of\r\n     * unprocessed inputs; the new input is sent to the server.\r\n     */\r\n    recordInput() {\r\n        if (!this.clientPlayer) {\r\n            return;\r\n        }\r\n\r\n        // obtain the direction of movement by subtracting the mouse position from the player's position\r\n        let mouseDirection = vector.subtract(\r\n            this.clientState.mousePosition,\r\n            vector.construct(\r\n                this.clientPlayer.position.x - this.camera.xView,\r\n                this.clientPlayer.position.y - this.camera.yView\r\n            )\r\n        );\r\n\r\n        // normalize the mouse direction using various scaling methods\r\n        let normalizedDirection = this.normalizeDirection(mouseDirection);\r\n\r\n        // increase the input number before adding the next input\r\n        this.inputNumber++;\r\n\r\n        // store the input along with a time and the input number for identification\r\n        let newInput = {\r\n            time: this.localTime,\r\n            direction: normalizedDirection,\r\n            number: this.inputNumber\r\n        };\r\n\r\n        // add the input to the array for later processing\r\n        this.clientPlayer.inputs.push(newInput);\r\n\r\n        // send the input to the server for processing\r\n        this.playerSocket.emit('input', newInput);\r\n    }\r\n\r\n\r\n    /**\r\n     * Aligns the client with the server by identifying the common\r\n     * player inputs, rendering them, and removing them\r\n     */\r\n    processServerUpdatePosition() {\r\n        if (!this.clientPlayer || !this.serverUpdates.length) {\r\n            return;\r\n        }\r\n\r\n        //console.log('processing server update');\r\n        const latestServerUpdate = this.serverUpdates[this.serverUpdates.length - 1];\r\n\r\n        // obtain the most recent server position of the client player\r\n        const serverPosition = latestServerUpdate.players[this.clientPlayerId].position;\r\n\r\n        const serverLastRenderedInputNumber = latestServerUpdate.players[this.clientPlayerId].lastRenderedInputNumber;\r\n        if (serverLastRenderedInputNumber) {\r\n            // locate where the last rendered server update happens in the local updates array\r\n            let latestServerUpdateIndex = -1;\r\n            for (let i = 0; i < this.clientPlayer.inputs.length; i++) {\r\n                if (this.clientPlayer.inputs[i].number == serverLastRenderedInputNumber) {\r\n                    latestServerUpdateIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // remove updates we have already processed locally\r\n            if (latestServerUpdateIndex > -1) {\r\n                // remove the inputs already processed on the server\r\n                this.clientPlayer.inputs.splice(0, latestServerUpdateIndex + 1);\r\n                // change the position to the latest server position\r\n                this.clientPlayer.position = vector.generate(serverPosition); // TODO keep this?\r\n                this.clientPlayer.lastRenderedInputNumber = latestServerUpdateIndex;\r\n                // trigger another update to read the remaining inputs\r\n                this.updatePhysics();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This handles the interpolation of players' positions by reading from server inputs.\r\n     */\r\n    processServerUpdates() {\r\n\r\n        // return if no inputs exist\r\n        if(!this.serverUpdates.length) {\r\n            return;\r\n        }\r\n\r\n        // record the current local time\r\n        const currentTime = this.clientTime;\r\n        let targetUpdate = null;\r\n        let previousUpdate = null;\r\n\r\n        // find a set of updates which 'contain' the current time\r\n        for(let i = 0; i < this.serverUpdates.length - 1; i++) {\r\n            const currentUpdate = this.serverUpdates[i];\r\n            const nextUpdate = this.serverUpdates[i + 1];\r\n            if(currentTime > currentUpdate.time && currentTime <= nextUpdate.time) {\r\n                targetUpdate = nextUpdate;\r\n                previousUpdate = currentUpdate;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // if no target can be found, simply use the least recent update\r\n        if(!targetUpdate) {\r\n            // console.log('using 0th update');\r\n            targetUpdate = this.serverUpdates[0];\r\n            previousUpdate = this.serverUpdates[0];\r\n        }\r\n\r\n        // set the new positions based on interpolation\r\n        if(targetUpdate && previousUpdate) {\r\n\r\n            // calculate the interpolation point (on [0, 1]) based on the\r\n            // position of the current time with respect to both chosen times\r\n            this.targetTime = targetUpdate.time;\r\n            const difference = this.targetTime - currentTime;\r\n            const maxDifference = (targetUpdate.time - previousUpdate.time);\r\n            let interpolationPoint = 0;\r\n\r\n            // set the interpolation point to the ratio of the actual difference to the max difference\r\n            // if the max difference is zero, we simply keep the interpolation point at zero\r\n            if (maxDifference != 0) {\r\n                interpolationPoint = (difference / maxDifference);\r\n            }\r\n\r\n            if (interpolationPoint > 1) {\r\n                // this indicates some sort of logical error has occurred\r\n                console.log('Error: interpolation point > 1');\r\n            }\r\n\r\n            // get the most recent server update\r\n            const lastServerUpdate = this.serverUpdates[this.serverUpdates.length - 1];\r\n\r\n            // update each player\r\n            for (let playerId in this.players) {\r\n                // whether or not to allow the given player to have its position updated\r\n                const allowPlayer = this.predictMovement || (playerId != this.clientPlayerId);\r\n                if (allowPlayer && this.players.hasOwnProperty(playerId)) {\r\n                    try {\r\n                        // calculate the theoretical position of the current player\r\n                        const playerTargetPosition = lastServerUpdate.players[playerId].position;\r\n                        const playerPastPosition = previousUpdate.players[playerId].position;\r\n                        const theoreticalPlayerPosition = vector.interpolate(\r\n                            playerTargetPosition,\r\n                            playerPastPosition,\r\n                            interpolationPoint\r\n                        );\r\n\r\n                        // smooth the transition by interpolating between the client position and server position\r\n                        this.players[playerId].position = vector.interpolate(\r\n                            this.players[playerId].position,\r\n                            theoreticalPlayerPosition,\r\n                            this.clientSmoothing\r\n                        );\r\n\r\n\r\n                        // set the blocks array for this player according to the server update\r\n                        this.players[playerId].blocks = targetUpdate.players[playerId].blocks;\r\n\r\n                        // this is the old broken way\r\n                        // this.players[playerId].position = vector.interpolate(\r\n                        //     this.players[playerId].position,\r\n                        //     theoreticalPlayerPosition,\r\n                        //     this.physicsDeltaTime * this.clientSmoothing\r\n                        // );\r\n\r\n                    } catch (error) {\r\n                        // this probably means a player was added and the server records are inconsistent\r\n                        // this error is ok if it only occurs a small number of times after a player is added\r\n                        console.log('Caught server update history error - ' + error);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This allows the client to connect to the server\r\n     * and establish a number of events to be triggered\r\n     * under certain conditions.\r\n     */\r\n    connect() {\r\n\r\n        // connect to the server\r\n        this.playerSocket = io();\r\n\r\n        // handle the disconnect event\r\n        this.playerSocket.on('disconnect', this.onDisconnect.bind(this));\r\n\r\n        // handle the reception of a server update\r\n        this.playerSocket.on('server-update', this.onServerUpdate.bind(this));\r\n\r\n        // handle the altering of a solution\r\n        this.playerSocket.on('solution-changed', this.onSolutionChanged.bind(this));\r\n\r\n        // handle the reception of a position set command\r\n        this.playerSocket.on('set-position', this.onSetPosition.bind(this));\r\n\r\n        // handle the initial information transferred upon connection\r\n        this.playerSocket.on('connected', this.onConnected.bind(this));\r\n\r\n        // handle the addition of a player to the game\r\n        this.playerSocket.on('player-added', this.onPlayerAdded.bind(this));\r\n\r\n        // handle the removal of players from the game\r\n        this.playerSocket.on('player-removed', this.onPlayerRemoved.bind(this));\r\n\r\n        // handle the reception of a ping\r\n        this.playerSocket.on('manual-ping', this.onPing.bind(this));\r\n\r\n        let name = localStorage.getItem('name');\r\n        this.playerSocket.emit('playername', {name: name});\r\n        console.log(name);\r\n    }\r\n\r\n    /**\r\n     * Updates the clients position status and sends an\r\n     * acknowledgement to the server.\r\n     * @param data The data from the server.\r\n     * @param callback The function to execute on the server.\r\n     */\r\n    onSetPosition(data, callback) {\r\n        this.lockPosition = data.locked;\r\n        callback();\r\n    }\r\n\r\n    /**\r\n     * Updates the client's current solution from server data.\r\n     * @param data The data from te server, indicating teh new solution index.\r\n     */\r\n    onSolutionChanged(data) {\r\n        console.log('solution changed to ' + data.solutionIndex);\r\n        this.solution = this.possibleSolutions[data.solutionIndex];\r\n    }\r\n    /**\r\n     * Responds to a player added event by adding the new\r\n     * player to the list.\r\n     * @param data The event data.\r\n     */\r\n    onPlayerAdded(data) {\r\n        // add the new player to the list of players\r\n        this.players[data.clientPlayerId] = data.player;\r\n    }\r\n\r\n    /**\r\n     * Responds to a player removed event by removing the player\r\n     * from the list.\r\n     * @param data The event data.\r\n     */\r\n    onPlayerRemoved(data) {\r\n        // remove the player from the list of players\r\n        console.log('removing player ' + data.clientPlayerId);\r\n        delete this.players[data.clientPlayerId];\r\n    }\r\n\r\n    /**\r\n     * Handles the transfer of information from server\r\n     * to client when connection occurs.\r\n     * @param data The data receive on connection.\r\n     */\r\n    onConnected(data) {\r\n        // assign the client player's id and the array of players\r\n        this.clientPlayerId = data.clientPlayerId;\r\n        this.players = data.players;\r\n\r\n        // create an actual player object for the client player\r\n        this.players[this.clientPlayerId] = Player.lightCopy(this.players[this.clientPlayerId]);\r\n\r\n        // assign the client player to the player identified by the client player id\r\n        this.clientPlayer = this.players[this.clientPlayerId];\r\n\r\n        // assign the list of blocks\r\n        this.blocks = data.blocks;\r\n\r\n        // assign the current solution\r\n        this.solution = this.possibleSolutions[data.solutionIndex];\r\n        console.log(data.solutionIndex);\r\n        console.log(this.solution);\r\n\r\n        // set the camera to track the client player\r\n        this.camera.setTarget(this.clientPlayer, this.canvas.width / 2, this.canvas.height / 2);\r\n\r\n        // obtain the server time based on ping data\r\n        this.serverTime = data.time + this.netLatency;\r\n    }\r\n\r\n    /**\r\n     * Updates the net ping and latency measures.\r\n     * @param data The data received from a ping message.\r\n     */\r\n    onPing(data) {\r\n        this.netPing = new Date().getTime() - data.time;\r\n        this.netLatency = this.netPing / 2;\r\n    }\r\n\r\n    onDisconnect(data) {\r\n        // TODO this is a stub\r\n        console.log('disconnected: ' + this.clientPlayerId);\r\n    }\r\n\r\n    /**\r\n     * Responds ot a server update event by recording the update\r\n     * in the buffer and processing the update data.\r\n     * @param update the server update data.\r\n     */\r\n     onServerUpdate(update){\r\n\r\n        // store the server time (note this is affected by latency)\r\n        this.serverTime = update.time;\r\n        if (this.netLatency > 80) {\r\n            console.log('Warning: high latency');\r\n        }\r\n\r\n        // set the blocks equal to the server copy TODO use interpolation?\r\n        this.blocks = update.blocks;\r\n\r\n        //Update our local offset time from the last server update\r\n        this.clientTime = this.serverTime - this.clientServerOffset;\r\n\r\n        // store the update\r\n        this.serverUpdates.push(update);\r\n\r\n        // if the string of updates are too long, remove the least recent\r\n        if(this.serverUpdates.length >= (FPS * this.bufferLength)) {\r\n            this.serverUpdates.splice(0,1);\r\n        }\r\n\r\n        // update the oldest time still accurately recorded\r\n        this.oldestUpdateTime = this.serverUpdates[0].time;\r\n\r\n        // update player scores\r\n        for (let playerId in update.players) {\r\n            if (update.players.hasOwnProperty(playerId) && this.players.hasOwnProperty(playerId)) {\r\n                this.players[playerId].score = update.players[playerId].score;\r\n                this.players[playerId].name = update.players[playerId].name;\r\n            }\r\n        }\r\n\r\n        // handle position updates from the server and interpolate with local positions\r\n        this.processServerUpdatePosition();\r\n    }\r\n}\r\n\r\n/*********************************** Drawing Functions ***********************************/\r\n\r\n/**\r\n * Draws a trapezoid with the given points.\r\n * @param context the context on which to render the trapezoid.\r\n * @param color the color of the trapezoid.\r\n * @param x1 The x coordinate of the first point in the trapezoid.\r\n * @param y1 The y coordinate of the first point in the trapezoid.\r\n * @param x2 The x coordinate of the second point in the trapezoid.\r\n * @param y2 The y coordinate of the second point in the trapezoid.\r\n * @param x3 The x coordinate of the third point in the trapezoid.\r\n * @param y3 The y coordinate of the third point in the trapezoid.\r\n * @param x4 The x coordinate of the fourth point in the trapezoid.\r\n * @param y4 The y coordinate of the fourth point in the trapezoid.\r\n */\r\nfunction trapezoid(context, color, x1, y1, x2, y2, x3, y3, x4, y4){\r\n    context.beginPath();\r\n    context.moveTo(x1,y1);\r\n    context.lineTo(x2,y2);\r\n    context.lineTo(x3,y3);\r\n    context.lineTo(x4,y4);\r\n    context.closePath();\r\n    context.fillStyle = color;\r\n    context.fill();\r\n}\r\n\r\n/**\r\n * Draws a rectangle in the given context.\r\n * @param context The context on which ot render the rectangle.\r\n * @param x The x coordinate of the upper-left corner of the rectangle.\r\n * @param y The y coordinate of the upper-left corner of the rectangle.\r\n * @param width The width of the rectangle.\r\n * @param height The height of the rectangle.\r\n * @param lineWidth The outline width of the rectangle.\r\n * @param opacity The opacity of te fill and outlines.\r\n * @param fillColor The fill color of the rectangle.\r\n * @param outlineColors An object containing an outline color for each edge\r\n * of the rectangle.\r\n */\r\nfunction drawRectangle(context, x, y, width, height, lineWidth, opacity, fillColor, outlineColors){\r\n\r\n    outlineColors = outlineColors || {\r\n            top: SQUARE_OUTLINE_COLOR_DEFAULT,\r\n            bottom: SQUARE_OUTLINE_COLOR_DEFAULT,\r\n            left: SQUARE_OUTLINE_COLOR_DEFAULT,\r\n            right: SQUARE_OUTLINE_COLOR_DEFAULT\r\n        };\r\n\r\n    context.lineWidth = lineWidth;\r\n    // use existing fillStyle if fillStyle is not supplied\r\n    fillColor = fillColor || context.fillStyle;\r\n\r\n\r\n    // set opacities\r\n    for (let key in outlineColors) {\r\n        if (outlineColors.hasOwnProperty(key)) {\r\n            outlineColors[key] = setOpacity(outlineColors[key], opacity);\r\n        }\r\n    }\r\n\r\n    fillColor = setOpacity(fillColor, opacity);\r\n\r\n    // use existing strokeStyle if any strokeStyle is not supplied\r\n    const strokeStyle = context.strokeStyle;\r\n\r\n    // context will be modified, so save it\r\n    context.save();\r\n\r\n    // miter the lines\r\n    context.lineJoin = \"miter\";\r\n\r\n    // context lines are always drawn half-in/half-out\r\n    // so context.lineWidth/2 is used a lot\r\n    const lw = context.lineWidth / 2;\r\n\r\n    // shortcut vars for boundaries\r\n    const leftBoundary = x - lw;\r\n    const rightBoundary = x + lw;\r\n    const topBoundary = y - lw;\r\n    const bottomBoundary = y + lw;\r\n\r\n    // top\r\n    trapezoid(\r\n        context,\r\n        outlineColors.top,\r\n        leftBoundary,\r\n        topBoundary,\r\n        rightBoundary + width,\r\n        topBoundary,\r\n        leftBoundary + width,\r\n        bottomBoundary,\r\n        rightBoundary,\r\n        bottomBoundary\r\n    );\r\n    // right\r\n    trapezoid(\r\n        context,\r\n        outlineColors.right,\r\n        rightBoundary + width,\r\n        topBoundary,\r\n        rightBoundary + width,\r\n        bottomBoundary + height,\r\n        leftBoundary + width,\r\n        topBoundary + height,\r\n        leftBoundary + width,\r\n        bottomBoundary\r\n    );\r\n    // bottom\r\n    trapezoid(\r\n        context,\r\n        outlineColors.bottom,\r\n        rightBoundary + width,\r\n        bottomBoundary + height,\r\n        leftBoundary,\r\n        bottomBoundary + height,\r\n        rightBoundary,\r\n        topBoundary + height,\r\n        leftBoundary + width,\r\n        topBoundary + height\r\n    );\r\n    // left\r\n    trapezoid(\r\n        context,\r\n        outlineColors.left,\r\n        leftBoundary,\r\n        bottomBoundary + height,\r\n        leftBoundary,\r\n        topBoundary,\r\n        rightBoundary,\r\n        bottomBoundary,\r\n        rightBoundary,\r\n        topBoundary + height\r\n    );\r\n\r\n    // fill\r\n    context.fillStyle = fillColor;\r\n    context.fillRect(x, y, width, height);\r\n    context.restore();\r\n    context.beginPath();\r\n}\r\n\r\n/*********************************** Block ***********************************/\r\n\r\nclass Block {\r\n    constructor(x, y, color) {\r\n        color = color || SQUARE_COLOR_BLOCK;\r\n        this.position = vector.construct(x, y);\r\n        this.velocity = vector.construct();\r\n        this.size = vector.construct(SQUARE_SIZE, SQUARE_SIZE);\r\n        this.color = color;\r\n        this.outlineColor = SQUARE_OUTLINE_COLOR_DEFAULT;\r\n        this.opacity = 1;\r\n        this.health = MAX_HEALTH;\r\n    }\r\n\r\n    static draw(block, context, camera, outlineColor, outlineEdge) {\r\n        outlineColor = outlineColor || SQUARE_OUTLINE_COLOR_DEFAULT;\r\n        let outlineColors = edge.formatColors(outlineEdge, outlineColor, SQUARE_OUTLINE_COLOR_DEFAULT);\r\n        drawRectangle(\r\n            context,\r\n            block.position.x - block.size.x / 2 - camera.xView,\r\n            block.position.y - block.size.y / 2 - camera.yView,\r\n            block.size.x,\r\n            block.size.y,\r\n            OUTLINE_SIZE,\r\n            block.opacity,\r\n            block.color,\r\n            outlineColors\r\n        );\r\n    }\r\n\r\n    static incrementVelocity(block) {\r\n        // TODO implement if needed\r\n    }\r\n}\r\n\r\n\r\n/*********************************** Player ***********************************/\r\n\r\nclass Player {\r\n    constructor() {\r\n        // initialize rendering values\r\n        this.color = SQUARE_COLOR_PLAYER;\r\n\r\n        // set initial current state values\r\n        this.position = vector.construct(20, 20);\r\n        this.size = vector.construct(SQUARE_SIZE, SQUARE_SIZE);\r\n\r\n        // store the previous state of the player\r\n        this.previousState = {\r\n            position: vector.construct()\r\n        };\r\n\r\n        //initializes the player's score\r\n        this.score = 0;\r\n\r\n        //initializes the player's name\r\n        //TODO: RIGHT NOW THIS IS JUST A PLACEHOLDER. THIS SHOULD BE INITALIZED WITH THE PLAYER'S ACTUAL NAME\r\n        this.name = \"\";\r\n\r\n        // store the blocks a player has\r\n        this.blocks = [new Block(0, 0, this.color)];\r\n\r\n        // store the input history\r\n        this.inputs = [];\r\n        this.lastRenderedInputNumber = 0;\r\n        this.lastInputTime = new Date().getTime();\r\n\r\n        // store the id of the block closest to it\r\n        this.candidateBlockId = '';\r\n        this.activeBlockIndex = 0;\r\n        this.activeEdge = edge.NONE;\r\n    }\r\n\r\n    /**\r\n     * Draws the given player.\r\n     * @param player The player object to draw.\r\n     * @param context The context in which to draw.\r\n     * @param camera the camera object used for offsetting\r\n     * the players position to reflect a centered client player.\r\n     */\r\n    static draw(player, context, camera) {\r\n        for (let i = 0; i < player.blocks.length; i++) {\r\n            let activeEdge = edge.NONE;\r\n            if (i == player.activeBlockIndex && player.activeEdge) {\r\n                activeEdge = player.activeEdge;\r\n            }\r\n            let outlineColors = edge.formatColors(\r\n                activeEdge,\r\n                SQUARE_OUTLINE_COLOR_ACTIVE,\r\n                SQUARE_OUTLINE_COLOR_DEFAULT\r\n            );\r\n\r\n            let xOffset = player.blocks[i].position.x * (SQUARE_SEPARATION);\r\n            let yOffset = player.blocks[i].position.y * (SQUARE_SEPARATION);\r\n\r\n\r\n            let xPosition = player.position.x - player.size.x / 2 + xOffset;\r\n            let yPosition = player.position.y - player.size.y / 2 + yOffset;\r\n\r\n\r\n            drawRectangle(\r\n                context,\r\n                xPosition - camera.xView,\r\n                yPosition - camera.yView,\r\n                player.size.x,\r\n                player.size.y,\r\n                OUTLINE_SIZE,\r\n                player.blocks[i].opacity,\r\n                player.blocks[i].color,\r\n                outlineColors\r\n            );\r\n\r\n\r\n\r\n        }\r\n\r\n\r\n        let x = player.blocks[0].position.x * (SQUARE_SEPARATION);\r\n        let y = player.blocks[0].position.y * (SQUARE_SEPARATION);\r\n        let xPos = player.position.x - player.size.x / 2 + x;\r\n        let yPos = player.position.y - player.size.y / 2 + y;\r\n\r\n        context.fillStyle= \"#999\";\r\n        context.strokeStyle=\"#999\";\r\n\r\n\r\n        // Set rectangle values\r\n        var rectX = xPos - camera.xView + 50;\r\n        var rectY = yPos - camera.yView + 40;\r\n        // var rectWidth = 50;\r\n        // var rectHeight = 22.5;\r\n        // var cornerRadius = 10;\r\n        //\r\n        // // Set  rounded corners\r\n        // context.lineJoin = \"round\";\r\n        // context.lineWidth = cornerRadius;\r\n        //\r\n        // // Change origin and dimensions to match true size (a stroke makes the shape a bit larger)\r\n        // context.strokeRect(rectX+(cornerRadius/2), rectY+(cornerRadius/2), rectWidth-cornerRadius, rectHeight-cornerRadius);\r\n        // context.fillRect(rectX+(cornerRadius/2), rectY+(cornerRadius/2), rectWidth-cornerRadius, rectHeight-cornerRadius);\r\n\r\n        //Show player's name:\r\n        context.font = \"bold 18px verdana, sans-serif \";\r\n        context.fillStyle = \"#fff\";\r\n        context.fillText(\r\n            player.name,\r\n            rectX + 5,\r\n            rectY + 9,\r\n        );\r\n\r\n\r\n\r\n        let wView = camera.wView;\r\n        let hView = camera.hView;\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Creates a new Player from a ServerPlayer or Player object.\r\n     * Note that the generated player will not have unique fields,\r\n     * as the references will still point to the original player.\r\n     * @param player The player object to copy.\r\n     * @returns {Player}\r\n     */\r\n    static lightCopy(player) {\r\n        let copy = new Player();\r\n        copy.position = player.position;\r\n        copy.previousState.position = player.previousState.position;\r\n        copy.inputs = player.inputs;\r\n        copy.blocks = player.blocks;\r\n        copy.lastRenderedInputNumber = player.lastRenderedInputNumber;\r\n        copy.lastInputTime = player.lastInputTime;\r\n        copy.score = player.score;\r\n        copy.name = player.name;\r\n        return copy;\r\n    }\r\n}\r\n\r\n/**\r\n * An extension of the normal player object, containing\r\n * references to the player's socket object as well as\r\n * the player's corresponding game object.  This information\r\n * is only useful on the server.\r\n */\r\nclass ServerPlayer extends Player {\r\n    /**\r\n     * Creates a new server player.\r\n     * @param game The game object corresponding to the game\r\n     * this player is in.\r\n     * @param playerSocket the socket object corresponding to\r\n     * this player.\r\n     */\r\n    constructor(game, playerSocket) {\r\n        super();\r\n        this.playerSocket = playerSocket;\r\n        this.game = game;\r\n    }\r\n}\r\n\r\n\r\n/*********************************** Initializations ***********************************/\r\n\r\nif (onServer()) {\r\n    // export information if we are on the server\r\n    module.exports = {\r\n        TIMER_PERIOD: TIMER_PERIOD,\r\n        MAX_PLAYERS_PER_GAME: MAX_PLAYERS_PER_GAME,\r\n        ServerGameLogic: ServerGameLogic,\r\n        ClientGameLogic: ClientGameLogic,\r\n        Player: Player,\r\n        Block: Block,\r\n        ServerPlayer: ServerPlayer\r\n    };\r\n} else {\r\n    // fix request animation frame issues on the client\r\n    (function () {\r\n\r\n        const framePeriod = FPS / 1000;\r\n        let lastTime = 0;\r\n        const vendors = ['ms', 'moz', 'webkit', 'o'];\r\n\r\n        for (let x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {\r\n            window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\r\n            window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\r\n                window[vendors[x] + 'CancelRequestAnimationFrame'];\r\n        }\r\n\r\n        if (!window.requestAnimationFrame) {\r\n            window.requestAnimationFrame = function (callback, element) {\r\n                const currentTime = Date.now();\r\n                const waitTime = Math.max(0, framePeriod - (currentTime - lastTime));\r\n                const id = window.setTimeout(function () {\r\n                    callback(currentTime + waitTime);\r\n                }, waitTime);\r\n                lastTime = currentTime + waitTime;\r\n                return id;\r\n            };\r\n        }\r\n\r\n        if (!window.cancelAnimationFrame) {\r\n            window.cancelAnimationFrame = function (id) {\r\n                clearTimeout(id);\r\n            };\r\n        }\r\n    }());\r\n}\r\n\r\n"]}