{"version":3,"sources":["game-server.js"],"names":[],"mappings":"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","file":"game-server-compiled.js","sourcesContent":["\r\nconst GameObjects = require('./public/game-compiled.js'); // TODO xxx changed from game\r\nconst ServerGameLogic = GameObjects.ServerGameLogic;\r\nconst Player = GameObjects.Player;\r\nconst Block = GameObjects.Block;\r\nconst ServerPlayer = GameObjects.ServerPlayer;\r\nconst uuid = require('uuid/v1');\r\n\r\n// the initial number of blocks to be generated when the game starts\r\nconst INITIAL_NUM_BLOCKS = 160;\r\n\r\n// the time (in ms) between server updates\r\nconst SERVER_UPDATE_PERIOD = 45;\r\n\r\n// define basic game container object\r\nconst exports = module.exports = {\r\n    games: {},\r\n    numGames: 0,\r\n    addGame: function (game) {\r\n        this.games[game.gameId] = game;\r\n        this.numGames++;\r\n    },\r\n    removeGame: function (gameId) {\r\n        delete this.games[gameId];\r\n        this.numGames--;\r\n    },\r\n    removePlayer: function (gameId, playerId) {\r\n        if (!this.games[gameId]) {\r\n            return;\r\n        }\r\n        this.games[gameId].removePlayer(playerId);\r\n        if (!this.games[gameId].numPlayers) {\r\n            console.log('Deleting game ' + gameId);\r\n            delete this.games[gameId];\r\n            this.numGames--;\r\n        }\r\n    }\r\n\r\n};\r\n\r\n// indicates the current simulated time, in seconds\r\nexports.localTime = 0;\r\n\r\n// indicates the current delta time (time between renderings) in milliseconds\r\nexports.deltaTime = 0;\r\n\r\n// indicates the time at which the last 'deltaTime' value was obtained\r\nexports.previousTime = new Date().getTime();\r\n\r\n// create physics loop to increment simulated time\r\nsetInterval(function () {\r\n\r\n    // reassign the delta time according to the current date\r\n    const currentTime = new Date().getTime();\r\n    exports.deltaTime = currentTime - exports.deltaTime;\r\n    exports.previousTime = currentTime;\r\n\r\n    // increment the local time by the new delta time\r\n    exports.localTime += exports.deltaTime / 1000.0;\r\n\r\n}, GameObjects.TIMER_PERIOD);\r\n\r\n/**\r\n * Sends a response to a ping from a player.\r\n * @param playerSocket The socket object of the player.\r\n * @param data The received ping data.\r\n */\r\nexports.onPing = function (playerSocket, data) {\r\n    // resend a duplicate ping message\r\n    playerSocket.emit('manual-ping', data);\r\n};\r\n\r\n/**\r\n * Passes input data from a player to the game logic\r\n * @param playerSocket The socket object of the player\r\n * who sent input.\r\n * @param data The data from the input.\r\n */\r\nexports.onInput = function (playerSocket, data) {\r\n    // forward to game logic\r\n    if (playerSocket && playerSocket.clientPlayerId && playerSocket.game && playerSocket.game.gameLogic) {\r\n        playerSocket.game.gameLogic.processClientUpdate(playerSocket.clientPlayerId, data);\r\n    }\r\n};\r\n\r\n/**\r\n * Processes data from an attach event.  The attached\r\n * block is removed from the list of blocks and passed\r\n * to the respective player.\r\n * @param playerSocket The socket object of the corresponding player.\r\n * @param data The data from the attach event.\r\n */\r\nexports.onAttach = function (playerSocket, data) {\r\n    // check if the block is still in the array\r\n    let gameLogic = playerSocket.game.gameLogic;\r\n    if (gameLogic.blocks[data.blockId]) {\r\n        // remove the block from the list\r\n        delete gameLogic.blocks[data.blockId];\r\n\r\n        // add the block to this copy of the player\r\n        gameLogic.players[data.playerId].blocks.push(new Block(data.relativePosition.x, data.relativePosition.y));\r\n    }\r\n};\r\n\r\n/**\r\n * Extracts data from a detach event, and passes this data to the\r\n * server game logic object for processing.\r\n * @param playerSocket The socket object for the respective player.\r\n * @param data The data from the detach.\r\n */\r\nexports.onDetach = function(playerSocket, data) {\r\n    // remove and retrieve the most recently added block\r\n    let gameLogic = playerSocket.game.gameLogic;\r\n    if (!gameLogic.players[data.playerId]) {\r\n        return;\r\n    }\r\n    gameLogic.detach(data.playerId);\r\n\r\n};\r\n\r\n/************************************** Game ******************************/\r\n/**\r\n * This object contains simple information\r\n * about a gameLogic gameLogic, including its ID,\r\n * the list of players (identified by their IDs),\r\n * and the number of players in the gameLogic.  This\r\n * object also contains a reference to a unique\r\n * GameLogic object to simulate the physics of\r\n * the gameLogic.\r\n */\r\nclass Game {\r\n\r\n    /**\r\n     * Creates a new game object with a unique\r\n     * gameId and a new game logic object.\r\n     */\r\n    constructor(numBlocks) {\r\n        this.gameId = uuid();\r\n        this.playerSockets = {};\r\n        this.numPlayers = 0;\r\n        this.gameLogic = new ServerGameLogic(this);\r\n        this.gameLogic.generateBlocks(numBlocks);\r\n    }\r\n\r\n    /**\r\n     * Adds a player's playerSocket object to the list of players.\r\n     * @param playerSocket The player to add.\r\n     */\r\n    addPlayer(playerSocket) {\r\n        // add player to game object\r\n        this.playerSockets[playerSocket.clientPlayerId] = playerSocket;\r\n        this.numPlayers++;\r\n        // add player to game logic object\r\n        const players = this.gameLogic.players;\r\n        players[playerSocket.clientPlayerId] = new ServerPlayer(this, playerSocket);\r\n\r\n        // send a player added event to each client\r\n        for (let playerId in players) {\r\n            if (playerId != playerSocket.clientPlayerId && players.hasOwnProperty(playerId)) {\r\n                players[playerId].playerSocket.emit('player-added', {\r\n                    clientPlayerId: playerSocket.clientPlayerId,\r\n                    player: Player.lightCopy(players[playerSocket.clientPlayerId])\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes a player from the game.\r\n     * @param playerId The id of the player to remove.\r\n     */\r\n    removePlayer(playerId) {\r\n        // remove player from game object\r\n        delete this.playerSockets[playerId];\r\n        this.numPlayers--;\r\n        // remove player from game logic object\r\n        this.gameLogic.removePlayer(playerId);\r\n    }\r\n\r\n    /**\r\n     * Starts updating the gameLogic on the server.\r\n     */\r\n    start() {\r\n        setInterval(function () {\r\n            this.gameLogic.update(new Date().getTime());\r\n        }.bind(this), SERVER_UPDATE_PERIOD);\r\n\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Creates a gameLogic with one player and begins the gameLogic.\r\n * @param playerSocket The playerSocket object of the player\r\n * who is creating the gameLogic.\r\n * @returns {Game} The newly created game object.\r\n */\r\nexports.createGame = function(playerSocket) {\r\n\r\n    // create a new gameLogic object and add it to the list\r\n    let game = new Game(INITIAL_NUM_BLOCKS);\r\n    exports.addGame(game);\r\n\r\n    // add the player to the new game\r\n    game.addPlayer(playerSocket);\r\n\r\n    // start the gameLogic loop on the server\r\n    game.start();\r\n\r\n    console.log('New game created at time ' + game.gameLogic.localTime);\r\n    return game;\r\n};\r\n\r\n\r\n/**\r\n * Removes the given game from the list\r\n * of current games.\r\n * @param gameId The ID of the game to remove.\r\n */\r\nexports.endGame = function(gameId) {\r\n    const game = exports.games[gameId];\r\n    if (game) {\r\n        exports.removeGame(gameId);\r\n    } else {\r\n        console.log('Game could not be deleted because gameId was invalid');\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * Attempts to find a gameLogic for the given player\r\n * to join.  If no gameLogic can be found, a new gameLogic\r\n * is created.\r\n * @param playerSocket The playerSocket object for the\r\n * player who wishes to join a gameLogic.\r\n */\r\nexports.findGame = function(playerSocket) {\r\n    let foundGame = false;\r\n    let game;\r\n    if(exports.numGames > 0) {\r\n        // try to find an open gameLogic\r\n        for (let gameId in exports.games) {\r\n            // eliminate items in the prototype chain\r\n            if (exports.games.hasOwnProperty(gameId)) {\r\n                const possibleGame = exports.games[gameId];\r\n                // check if the current gameLogic can handle more playerSockets\r\n                if (possibleGame.numPlayers < GameObjects.MAX_PLAYERS_PER_GAME) {\r\n                    foundGame = true;\r\n                    possibleGame.addPlayer(playerSocket);\r\n                    game = possibleGame;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // if no open games could be found, create a new gameLogic\r\n    if(!foundGame) {\r\n        game = this.createGame(playerSocket);\r\n    }\r\n\r\n    playerSocket.game = game;\r\n\r\n    // tell the player they connected, giving them their id and the list of players\r\n    let playersLightCopy = {};\r\n    for (let playerId in game.gameLogic.players) {\r\n        if (game.gameLogic.players.hasOwnProperty(playerId)) {\r\n            playersLightCopy[playerId] = Player.lightCopy(game.gameLogic.players[playerId]);\r\n        }\r\n    }\r\n\r\n    playerSocket.emit('connected', {\r\n        clientPlayerId: playerSocket.clientPlayerId,\r\n        serverTime: game.gameLogic.serverTime,\r\n        players: playersLightCopy,\r\n        blocks: game.gameLogic.blocks,\r\n        solutionIndex: game.gameLogic.possibleSolutions.indexOf(game.gameLogic.solution)\r\n    });\r\n};"]}